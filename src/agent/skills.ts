import fs from 'fs-extra';
import path from 'path';
import logger from '../utils/logger';
import { KnowledgeBaseService } from '../services/knowledge/service';

/**
 * Skill Loader - Dynamic Prompt and Knowledge Management
 * 
 * OVERVIEW:
 * This service manages "skills" which are markdown files containing instructions, 
 * protocols, or specific domain knowledge. It categorizes skills into three sources:
 * 1. System: Core protocols and behavioral rules (always loaded).
 * 2. User: Custom skills provided by the user (loaded on demand).
 * 3. AI: Skills learned or generated by the AI during execution (loaded on demand).
 * 
 * KEY FEATURES:
 * - Hot-reloading: Watches the skills directory for changes and updates the index.
 * - Knowledge Base Sync: Automatically syncs skill content to the vector database.
 * - Priority Sorting: System skills (alphabetical) > User/AI skills (recency).
 * - Prompt Engineering: Dynamically builds the system prompt by combining full 
 *   protocols with a searchable index of available on-demand skills.
 * 
 * @param workspace - The absolute path to the project workspace.
 */
export class SkillLoader {
  private baseDir: string;    // Root skills directory
  private systemDir: string;  // Core protocol directory
  private userDir: string;    // User-provided skill directory
  private aiDir: string;      // AI-generated skill directory

  constructor(workspace: string) {
    // Robust project root discovery by traversing up from the current module path.
    // This ensures stability regardless of how the application is launched.
    let projectRoot = path.resolve(__dirname);
    const root = path.parse(projectRoot).root;
    
    while (projectRoot !== root) {
      if (fs.existsSync(path.join(projectRoot, 'package.json'))) {
        break;
      }
      projectRoot = path.dirname(projectRoot);
    }
    
    // Fallback to current working directory if root discovery fails.
    if (projectRoot === root) {
      logger.warn('Could not find project root via package.json, falling back to process.cwd()');
      projectRoot = process.cwd();
    }

    // Set up directory structure under /skills
    this.baseDir = path.join(projectRoot, 'skills');
    this.systemDir = path.join(this.baseDir, 'system');
    this.userDir = path.join(this.baseDir, 'user');
    this.aiDir = path.join(this.baseDir, 'ai');

    // Start directory watcher for hot-reloading skills
    this.watchSkills();
    
    // Initial synchronization of all skills to the vector knowledge base.
    // Delayed to ensure the database service is fully initialized.
    setTimeout(() => {
        this.syncAllSkills().catch(err => logger.error(`Initial skill sync failed: ${err}`));
    }, 5000); 
  }

  /**
   * Syncs a single skill file's content to the Vector Knowledge Base.
   * This allows the AI to perform semantic searches over the skill library.
   * 
   * @param filePath - Absolute path to the skill markdown file.
   * @param source - The source category (system/user/ai).
   */
  private async syncSkillToDB(filePath: string, source: string) {
    const kb = KnowledgeBaseService.getInstance();
    if (!kb || !kb.isInitialized()) return;

    try {
      if (await fs.pathExists(filePath)) {
        const content = await fs.readFile(filePath, 'utf-8');
        const stats = await fs.stat(filePath);
        const name = path.basename(filePath);
        
        // Use filename as the primary key in the DB to allow updates/overwrites.
        const id = name; 
        const collection = `skills_${source}`; // Collections are split by source
        
        await kb.addDocument(content, {
            source: 'skill',
            type: source,
            path: filePath,
            mtime: stats.mtimeMs
        }, collection, id);
        
        logger.debug(`Synced skill ${name} to ${collection}`);
      }
    } catch (err) {
      logger.warn(`Failed to sync skill ${filePath} to DB: ${err}`);
    }
  }

  /**
   * Performs a full scan and sync of all skill categories to the DB.
   */
  public async syncAllSkills() {
      const kb = KnowledgeBaseService.getInstance();
      if (!kb || !kb.isInitialized()) return;
      
      logger.info('Syncing all skills to Knowledge Base...');
      const sources = [
          { dir: this.systemDir, name: 'system' },
          { dir: this.userDir, name: 'user' },
          { dir: this.aiDir, name: 'ai' }
      ];

      for (const { dir, name } of sources) {
          if (await fs.pathExists(dir)) {
              const files = await fs.readdir(dir);
              for (const file of files) {
                  // Only process markdown files
                  if (file.endsWith('.md')) {
                      await this.syncSkillToDB(path.join(dir, file), name);
                  }
              }
          }
      }
      logger.info('Skills sync completed.');
  }

  /**
   * Initializes a filesystem watcher on the skills directory.
   * Automatically regenerates INDEX.md and re-syncs to DB on any file change.
   */
  private watchSkills() {
    try {
      if (!fs.existsSync(this.baseDir)) {
         fs.mkdirSync(this.baseDir, { recursive: true });
      }

      logger.info(`Watching skills directory for changes: ${this.baseDir}`);
      let fsWait: NodeJS.Timeout | null = null;
      
      fs.watch(this.baseDir, { recursive: true }, (eventType, filename) => {
        // Ignore hidden files and the auto-generated index itself
        if (!filename || filename.startsWith('.') || filename === 'INDEX.md') return;
        
        // Simple debounce to prevent multiple triggers during rapid edits or batch moves
        if (fsWait) return;
        fsWait = setTimeout(async () => {
          fsWait = null;
          logger.info(`Skill file changed: ${filename}. Regenerating INDEX.md...`);
          const allSkills = await this.listSkills();
          await this.generateIndexFile(allSkills);
          
          // Trigger DB sync for updated content
          await this.syncAllSkills();
        }, 1000);
      });
    } catch (err) {
      logger.warn(`Failed to watch skills directory: ${err}`);
    }
  }

  /**
   * Scans a directory for .md files and retrieves their metadata.
   */
  private async getMdFilesWithStats(dir: string): Promise<{ path: string, name: string, mtime: number, source: string }[]> {
    if (!(await fs.pathExists(dir))) return [];
    const files = await fs.readdir(dir);
    const results = [];
    for (const file of files) {
      if (file.endsWith('.md')) {
        const filePath = path.join(dir, file);
        const stats = await fs.stat(filePath);
        results.push({
          path: filePath,
          name: file,
          mtime: stats.mtimeMs,
          source: path.basename(dir)
        });
      }
    }
    return results;
  }

  /**
   * Retrieves a prioritized list of all available skills.
   * Sort Order:
   * 1. System Skills (Alphabetical)
   * 2. User Skills (Most recent first)
   * 3. AI Skills (Most recent first)
   */
  async listSkills(): Promise<any[]> {
    const systemSkills = await this.getMdFilesWithStats(this.systemDir);
    const userSkills = await this.getMdFilesWithStats(this.userDir);
    const aiSkills = await this.getMdFilesWithStats(this.aiDir);
    
    return [
      ...systemSkills.sort((a, b) => a.name.localeCompare(b.name)),
      ...userSkills.sort((a, b) => b.mtime - a.mtime),
      ...aiSkills.sort((a, b) => b.mtime - a.mtime)
    ];
  }

  /**
   * Generates a combined prompt string for the AI's system message.
   * 
   * STRATEGY:
   * - System Protocols: Fully embedded in the prompt.
   * - User/AI Skills: Only headers and brief descriptions are embedded as a 
   *   searchable index to save context window tokens.
   * 
   * @param limit - Optional maximum number of dynamic skills to list in the index.
   */
  async loadSkillsPrompt(limit: number = 0): Promise<string> {
    try {
      const allSkills = await this.listSkills();
      
      // Ensure the auto-generated INDEX.md exists for external reference.
      const indexPath = path.join(this.baseDir, 'INDEX.md');
      if (!fs.existsSync(indexPath)) {
         logger.info('INDEX.md missing, generating initial index...');
         await this.generateIndexFile(allSkills);
      }

      if (allSkills.length === 0) return '';

      const systemSkills = allSkills.filter(s => s.source === 'system');
      const otherSkills = allSkills.filter(s => s.source !== 'system');
      
      let combinedPrompt = '';
      
      // 1. Embed System Protocols (Critical Behavior Instructions)
      for (const skill of systemSkills) {
        const content = await fs.readFile(skill.path, 'utf-8');
        combinedPrompt += `\n${content.trim()}\n`;
      }

      // 2. Embed "On-Demand" Skill Index (User & AI Generated)
      if (otherSkills.length > 0) {
        combinedPrompt += `\n## Available Skills Library (Load on Demand)\n`;
        combinedPrompt += `The following skills are available in the library. To use a skill, you MUST read its content first using the \`read_file\` tool with the provided path. Or use \`knowledge_search\` to find relevant skills by description.\n\n`;

        const effectiveLimit = limit > 0 ? Math.max(limit, 50) : 0;
        const skillsToShow = effectiveLimit > 0 ? otherSkills.slice(0, effectiveLimit) : otherSkills;

        for (const skill of skillsToShow) {
          const content = await fs.readFile(skill.path, 'utf-8');
          
          // Extract a concise description by finding the first non-header text block.
          const cleanLines = content.split('\n')
            .map(l => l.trim())
            .filter(l => l.length > 0 && !l.startsWith('#') && !l.startsWith('---'));
          
          const description = cleanLines.length > 0 
            ? cleanLines[0].substring(0, 150).replace(/`/g, '') 
            : 'No description provided';
            
          const timeStr = new Date(skill.mtime).toISOString().split('T')[0];
          
          combinedPrompt += `- **${skill.name}** (${timeStr})\n`;
          combinedPrompt += `  - Path: \`${skill.path}\`\n`;
          combinedPrompt += `  - Desc: ${description}...\n`;
        }
        
        if (effectiveLimit > 0 && otherSkills.length > effectiveLimit) {
            combinedPrompt += `\n... and ${otherSkills.length - effectiveLimit} more skills available in ${this.baseDir}\n`;
        }
      }

      return combinedPrompt;
    } catch (err: any) {
      logger.error(`Error loading skills: ${err.message}`);
      return '';
    }
  }

  /**
   * Persists a new skill generated by the AI to the 'ai' directory.
   * 
   * @param name - The name of the skill (will be sanitized for filename).
   * @param content - The full markdown content of the skill.
   */
  async saveAiSkill(name: string, content: string): Promise<string> {
    if (!await fs.pathExists(this.aiDir)) {
      await fs.ensureDir(this.aiDir);
    }

    // Sanitize filename to prevent directory traversal or invalid characters.
    const safeName = name.replace(/[^a-zA-Z0-9_-]/g, '_');
    const fileName = `${safeName}.md`;
    const filePath = path.join(this.aiDir, fileName);

    await fs.writeFile(filePath, content, 'utf-8');
    logger.info(`Saved new AI skill: ${filePath}`);
    
    // Trigger immediate index regeneration.
    await this.generateIndexFile(await this.listSkills());
    
    return filePath;
  }

  /**
   * Regenerates the INDEX.md file in the skills directory.
   * This provides a human-readable and AI-readable summary of the entire library.
   */
  private async generateIndexFile(skills: any[]): Promise<void> {
    try {
      const indexPath = path.join(this.baseDir, 'INDEX.md');
      let content = '# Skill Index\n\n';
      content += 'This file is auto-generated. Do not edit manually.\n';
      content += `Last Updated: ${new Date().toLocaleString()}\n\n`;
      
      const systemSkills = skills.filter(s => s.source === 'system');
      const userSkills = skills.filter(s => s.source === 'user');
      const aiSkills = skills.filter(s => s.source === 'ai');

      if (systemSkills.length > 0) {
        content += '## System Protocols (Always Loaded)\n';
        for (const skill of systemSkills) {
           content += `- [${skill.name}](./system/${skill.name})\n`;
        }
        content += '\n';
      }

      if (userSkills.length > 0) {
        content += '## User Skills (On-Demand)\n';
        for (const skill of userSkills) {
           const desc = await this.getSkillDescription(skill.path);
           content += `- [${skill.name}](./user/${skill.name}): ${desc}\n`;
        }
        content += '\n';
      }

      if (aiSkills.length > 0) {
        content += '## AI Skills (On-Demand)\n';
        for (const skill of aiSkills) {
           const desc = await this.getSkillDescription(skill.path);
           content += `- [${skill.name}](./ai/${skill.name}): ${desc}\n`;
        }
        content += '\n';
      }

      await fs.writeFile(indexPath, content, 'utf-8');
    } catch (err) {
      logger.error(`Failed to generate INDEX.md: ${err}`);
    }
  }

  /**
   * Extracts a short description from a skill file.
   */
  private async getSkillDescription(filePath: string): Promise<string> {
    try {
      const content = await fs.readFile(filePath, 'utf-8');
      const lines = content.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#') && !l.startsWith('---'));
      return lines.length > 0 ? lines[0].substring(0, 100).replace(/`/g, '') : 'No description';
    } catch {
      return 'Error reading file';
    }
  }
}
